import pygame
import random
import math
from enum import Enum
from dataclasses import dataclass
from typing import List, Tuple, Optional
import time

# Inicializar Pygame
pygame.init()

# Constantes
ANCHO = 1400
ALTO = 900
FPS = 60

# Colores m√°s realistas
COLORES = {
    'ASFALTO': (45, 45, 45),
    'ASFALTO_VIEJO': (55, 50, 45),  # Para calles del centro hist√≥rico
    'LINEA_AMARILLA': (255, 255, 100),
    'LINEA_BLANCA': (220, 220, 220),
    'ACERA': (180, 180, 180),
    'PIEDRA': (120, 110, 100),  # Para calles empedradas
    'EDIFICIO_COLONIAL': (160, 82, 45),
    'EDIFICIO_MODERNO': (100, 100, 120),
    'PLAZA': (85, 140, 85),
    'PASTO': (60, 120, 60),
    'TIERRA': (139, 125, 107),
    
    # Veh√≠culos con colores m√°s variados y realistas
    'AUTO_ROJO': (180, 30, 30),
    'AUTO_AZUL': (30, 80, 180),
    'AUTO_BLANCO': (240, 240, 240),
    'AUTO_NEGRO': (40, 40, 40),
    'COMBI_AMARILLA': (255, 200, 0),
    'COMBI_AZUL': (0, 120, 200),
    'MOTO_ROJA': (200, 50, 50),
    'MOTO_NEGRA': (60, 60, 60),
    'TAXI': (255, 255, 0),
    
    'SEMAFORO_ROJO': (255, 50, 50),
    'SEMAFORO_VERDE': (50, 255, 50),
    'SEMAFORO_AMARILLO': (255, 255, 50),
    'FONDO': (25, 35, 25),
    'TEXTO': (255, 255, 255)
}

class TipoVehiculo(Enum):
    AUTO = 1
    COMBI = 2
    MOTO = 3
    TAXI = 4

class EstadoSemaforo(Enum):
    ROJO = 1
    AMARILLO = 2
    VERDE = 3

class DireccionCalle(Enum):
    HORIZONTAL = 1
    VERTICAL = 2
    DIAGONAL = 3

@dataclass
class Punto:
    x: float
    y: float
    
    def distancia_a(self, otro: 'Punto') -> float:
        return math.sqrt((self.x - otro.x)**2 + (self.y - otro.y)**2)

@dataclass
class Calle:
    inicio: Punto
    fin: Punto
    ancho: int
    tipo: str  # 'principal', 'secundaria', 'empedrada'
    direccion: DireccionCalle
    velocidad_maxima: float

class Vehiculo:
    def __init__(self, tipo: TipoVehiculo, posicion: Punto, calle_actual: Calle):
        self.tipo = tipo
        self.posicion = posicion
        self.calle_actual = calle_actual
        self.direccion = self._calcular_direccion_inicial()
        self.velocidad_maxima = self._obtener_velocidad_maxima()
        self.velocidad_actual = 0
        self.velocidad_objetivo = 0
        self.tamano = self._obtener_tamano()
        self.color = self._obtener_color()
        self.ruta = []
        self.indice_ruta = 0
        self.tiempo_parada = 0
        self.comportamiento = self._obtener_comportamiento()
        self.carril = random.choice([-1, 1])  # Lado de la calle
        
    def _calcular_direccion_inicial(self) -> float:
        dx = self.calle_actual.fin.x - self.calle_actual.inicio.x
        dy = self.calle_actual.fin.y - self.calle_actual.inicio.y
        return math.atan2(dy, dx)
        
    def _obtener_velocidad_maxima(self) -> float:
        base_speeds = {
            TipoVehiculo.AUTO: 2.5,
            TipoVehiculo.COMBI: 1.8,
            TipoVehiculo.MOTO: 3.2,
            TipoVehiculo.TAXI: 2.0
        }
        # Ajustar por tipo de calle
        factor = 1.0
        if self.calle_actual.tipo == 'empedrada':
            factor = 0.6
        elif self.calle_actual.tipo == 'secundaria':
            factor = 0.8
            
        return base_speeds[self.tipo] * factor * random.uniform(0.8, 1.2)
    
    def _obtener_tamano(self) -> Tuple[int, int]:
        tamanos = {
            TipoVehiculo.AUTO: (22, 14),
            TipoVehiculo.COMBI: (35, 18),
            TipoVehiculo.MOTO: (14, 10),
            TipoVehiculo.TAXI: (22, 14)
        }
        return tamanos[self.tipo]
    
    def _obtener_color(self) -> Tuple[int, int, int]:
        colores_por_tipo = {
            TipoVehiculo.AUTO: [COLORES['AUTO_ROJO'], COLORES['AUTO_AZUL'], 
                               COLORES['AUTO_BLANCO'], COLORES['AUTO_NEGRO']],
            TipoVehiculo.COMBI: [COLORES['COMBI_AMARILLA'], COLORES['COMBI_AZUL']],
            TipoVehiculo.MOTO: [COLORES['MOTO_ROJA'], COLORES['MOTO_NEGRA']],
            TipoVehiculo.TAXI: [COLORES['TAXI']]
        }
        return random.choice(colores_por_tipo[self.tipo])
    
    def _obtener_comportamiento(self) -> dict:
        """Define comportamientos espec√≠ficos por tipo de veh√≠culo"""
        comportamientos = {
            TipoVehiculo.AUTO: {
                'paciencia': random.uniform(0.7, 1.0),
                'agresividad': random.uniform(0.3, 0.7),
                'tiempo_reaccion': random.uniform(0.5, 1.0)
            },
            TipoVehiculo.COMBI: {
                'paciencia': random.uniform(0.4, 0.8),
                'agresividad': random.uniform(0.6, 0.9),  # M√°s agresivas
                'tiempo_reaccion': random.uniform(0.8, 1.5),
                'paradas_frecuentes': True
            },
            TipoVehiculo.MOTO: {
                'paciencia': random.uniform(0.2, 0.5),
                'agresividad': random.uniform(0.8, 1.0),  # Muy agresivas
                'tiempo_reaccion': random.uniform(0.2, 0.5),
                'puede_zigzaguear': True
            },
            TipoVehiculo.TAXI: {
                'paciencia': random.uniform(0.5, 0.8),
                'agresividad': random.uniform(0.4, 0.8),
                'tiempo_reaccion': random.uniform(0.6, 1.0),
                'busca_pasajeros': True
            }
        }
        return comportamientos[self.tipo]
    
    def establecer_ruta(self, calles: List[Calle]):
        self.ruta = calles
        self.indice_ruta = 0
        
    def actualizar(self, otros_vehiculos: List['Vehiculo'], semaforos: List['Semaforo']):
        if not self.ruta or self.indice_ruta >= len(self.ruta):
            return False  # Veh√≠culo debe ser eliminado
            
        calle_actual = self.ruta[self.indice_ruta]
        
        # Calcular objetivo en la calle actual
        progreso = self._calcular_progreso_en_calle()
        if progreso >= 1.0:
            self.indice_ruta += 1
            if self.indice_ruta >= len(self.ruta):
                return False
            calle_actual = self.ruta[self.indice_ruta]
            self._actualizar_direccion()
        
        # Determinar velocidad objetivo
        self.velocidad_objetivo = self._calcular_velocidad_objetivo(otros_vehiculos, semaforos)
        
        # Comportamientos especiales
        self._aplicar_comportamiento_especial()
        
        # Suavizar cambios de velocidad
        self._actualizar_velocidad()
        
        # Mover veh√≠culo
        self._mover()
        
        return True
    
    def _calcular_progreso_en_calle(self) -> float:
        if not self.ruta:
            return 1.0
        calle = self.ruta[self.indice_ruta]
        total = calle.inicio.distancia_a(calle.fin)
        actual = calle.inicio.distancia_a(self.posicion)
        return min(actual / total, 1.0) if total > 0 else 1.0
    
    def _actualizar_direccion(self):
        if self.indice_ruta < len(self.ruta):
            calle = self.ruta[self.indice_ruta]
            dx = calle.fin.x - calle.inicio.x
            dy = calle.fin.y - calle.inicio.y
            self.direccion = math.atan2(dy, dx)
    
    def _calcular_velocidad_objetivo(self, otros_vehiculos: List['Vehiculo'], 
                                   semaforos: List['Semaforo']) -> float:
        vel_objetivo = self.velocidad_maxima
        
        # Verificar sem√°foros
        for semaforo in semaforos:
            if self._debe_detenerse_por_semaforo(semaforo):
                vel_objetivo = 0
                break
        
        # Verificar otros veh√≠culos
        vehiculo_adelante = self._encontrar_vehiculo_adelante(otros_vehiculos)
        if vehiculo_adelante:
            distancia = self.posicion.distancia_a(vehiculo_adelante.posicion)
            if distancia < 40:  # Muy cerca
                vel_objetivo = min(vel_objetivo, vehiculo_adelante.velocidad_actual * 0.5)
            elif distancia < 60:  # Cerca
                vel_objetivo = min(vel_objetivo, vehiculo_adelante.velocidad_actual * 0.8)
        
        return vel_objetivo
    
    def _debe_detenerse_por_semaforo(self, semaforo: 'Semaforo') -> bool:
        if semaforo.estado == EstadoSemaforo.VERDE:
            return False
            
        distancia = self.posicion.distancia_a(semaforo.posicion)
        if distancia > 80:  # Muy lejos
            return False
            
        # Verificar si se est√° acercando al sem√°foro
        dx = semaforo.posicion.x - self.posicion.x
        dy = semaforo.posicion.y - self.posicion.y
        angulo_al_semaforo = math.atan2(dy, dx)
        
        diferencia_angulo = abs(self.direccion - angulo_al_semaforo)
        diferencia_angulo = min(diferencia_angulo, 2 * math.pi - diferencia_angulo)
        
        return diferencia_angulo < math.pi / 3  # 60 grados
    
    def _encontrar_vehiculo_adelante(self, otros_vehiculos: List['Vehiculo']) -> Optional['Vehiculo']:
        vehiculo_mas_cercano = None
        distancia_minima = float('inf')
        
        for otro in otros_vehiculos:
            if otro == self:
                continue
                
            # Verificar si est√° adelante
            dx = otro.posicion.x - self.posicion.x
            dy = otro.posicion.y - self.posicion.y
            angulo_al_otro = math.atan2(dy, dx)
            
            diferencia_angulo = abs(self.direccion - angulo_al_otro)
            diferencia_angulo = min(diferencia_angulo, 2 * math.pi - diferencia_angulo)
            
            if diferencia_angulo < math.pi / 4:  # 45 grados adelante
                distancia = self.posicion.distancia_a(otro.posicion)
                if distancia < distancia_minima:
                    distancia_minima = distancia
                    vehiculo_mas_cercano = otro
        
        return vehiculo_mas_cercano
    
    def _aplicar_comportamiento_especial(self):
        # Combis pueden hacer paradas ocasionales
        if (self.tipo == TipoVehiculo.COMBI and 
            self.comportamiento.get('paradas_frecuentes') and
            random.random() < 0.001):  # 0.1% de chance por frame
            self.tiempo_parada = random.uniform(60, 180)  # 1-3 segundos a 60 FPS
        
        # Reducir tiempo de parada
        if self.tiempo_parada > 0:
            self.tiempo_parada -= 1
            self.velocidad_objetivo = 0
    
    def _actualizar_velocidad(self):
        aceleracion = 0.08 * self.comportamiento['agresividad']
        frenado = 0.15
        
        if self.velocidad_actual < self.velocidad_objetivo:
            self.velocidad_actual = min(
                self.velocidad_actual + aceleracion, 
                self.velocidad_objetivo
            )
        else:
            self.velocidad_actual = max(
                self.velocidad_actual - frenado, 
                max(0, self.velocidad_objetivo)
            )
    
    def _mover(self):
        # A√±adir algo de ruido para movimiento m√°s realista
        ruido = random.uniform(-0.1, 0.1) * (1 - self.comportamiento['paciencia'])
        direccion_con_ruido = self.direccion + ruido
        
        self.posicion.x += math.cos(direccion_con_ruido) * self.velocidad_actual
        self.posicion.y += math.sin(direccion_con_ruido) * self.velocidad_actual
    
    def dibujar(self, pantalla):
        # Dibujar sombra
        sombra_offset = 2
        self._dibujar_vehiculo(pantalla, 
                              Punto(self.posicion.x + sombra_offset, 
                                   self.posicion.y + sombra_offset),
                              (0, 0, 0, 100))
        
        # Dibujar veh√≠culo
        self._dibujar_vehiculo(pantalla, self.posicion, self.color)
        
        # Dibujar indicador de estado (opcional)
        if self.tiempo_parada > 0:
            pygame.draw.circle(pantalla, (255, 255, 0), 
                             (int(self.posicion.x), int(self.posicion.y - 20)), 3)
    
    def _dibujar_vehiculo(self, pantalla, posicion: Punto, color):
        ancho, alto = self.tamano
        cos_a = math.cos(self.direccion)
        sin_a = math.sin(self.direccion)
        
        # Puntos del rect√°ngulo
        puntos = [
            (-ancho/2, -alto/2), (ancho/2, -alto/2),
            (ancho/2, alto/2), (-ancho/2, alto/2)
        ]
        
        # Rotar y trasladar
        puntos_rotados = []
        for px, py in puntos:
            x_rot = px * cos_a - py * sin_a + posicion.x
            y_rot = px * sin_a + py * cos_a + posicion.y
            puntos_rotados.append((x_rot, y_rot))
        
        pygame.draw.polygon(pantalla, color, puntos_rotados)
        
        # Detalles adicionales
        if self.tipo == TipoVehiculo.TAXI:
            # Letrero de taxi
            pygame.draw.rect(pantalla, (0, 0, 0), 
                           (posicion.x - 8, posicion.y - 12, 16, 6))

class Semaforo:
    def __init__(self, posicion: Punto, tipo: str = 'normal'):
        self.posicion = posicion
        self.estado = EstadoSemaforo.VERDE
        self.tipo = tipo
        self.tiempo_cambio = time.time() + random.uniform(5, 12)
        
        # Tiempos m√°s realistas
        if tipo == 'principal':
            self.duracion_verde = random.uniform(8, 15)
            self.duracion_rojo = random.uniform(6, 12)
        else:
            self.duracion_verde = random.uniform(5, 10)
            self.duracion_rojo = random.uniform(4, 8)
            
        self.duracion_amarillo = 3
    
    def actualizar(self):
        tiempo_actual = time.time()
        if tiempo_actual >= self.tiempo_cambio:
            if self.estado == EstadoSemaforo.VERDE:
                self.estado = EstadoSemaforo.AMARILLO
                self.tiempo_cambio = tiempo_actual + self.duracion_amarillo
            elif self.estado == EstadoSemaforo.AMARILLO:
                self.estado = EstadoSemaforo.ROJO
                self.tiempo_cambio = tiempo_actual + self.duracion_rojo
            else:  # ROJO
                self.estado = EstadoSemaforo.VERDE
                self.tiempo_cambio = tiempo_actual + self.duracion_verde
    
    def dibujar(self, pantalla):
        # Poste del sem√°foro
        pygame.draw.rect(pantalla, (80, 80, 80), 
                        (self.posicion.x - 3, self.posicion.y - 20, 6, 40))
        
        # Caja del sem√°foro
        pygame.draw.rect(pantalla, (40, 40, 40), 
                        (self.posicion.x - 15, self.posicion.y - 25, 30, 20))
        
        # Luces
        colores = [(100, 100, 100)] * 3  # Apagadas por defecto
        if self.estado == EstadoSemaforo.ROJO:
            colores[0] = COLORES['SEMAFORO_ROJO']
        elif self.estado == EstadoSemaforo.AMARILLO:
            colores[1] = COLORES['SEMAFORO_AMARILLO']
        else:  # VERDE
            colores[2] = COLORES['SEMAFORO_VERDE']
        
        for i, color in enumerate(colores):
            pygame.draw.circle(pantalla, color, 
                             (int(self.posicion.x - 10 + i * 10), 
                              int(self.posicion.y - 15)), 4)

class SimulacionTrafico:
    def __init__(self):
        self.pantalla = pygame.display.set_mode((ANCHO, ALTO))
        pygame.display.set_caption("Simulaci√≥n Realista - Tr√°fico del Centro Hist√≥rico del Cusco")
        self.reloj = pygame.time.Clock()
        
        self.vehiculos = []
        self.semaforos = []
        self.calles = self._crear_red_calles_cusco()
        self._crear_semaforos_estrategicos()
        
        # Estad√≠sticas mejoradas
        self.vehiculos_generados = 0
        self.tiempo_ultima_generacion = time.time()
        self.estadisticas = {
            'autos': 0, 'combis': 0, 'motos': 0, 'taxis': 0,
            'promedio_velocidad': 0, 'congestion': 0
        }
        
        # Generaci√≥n m√°s inteligente
        self.patrones_horarios = self._crear_patrones_horarios()
        self.hora_simulada = 8.0  # 8:00 AM
    
    def _crear_red_calles_cusco(self) -> List[Calle]:
        """Red de calles m√°s realista del centro hist√≥rico"""
        calles = []
        
        # Avenidas principales
        calles.extend([
            # Av. El Sol - arteria principal este-oeste
            Calle(Punto(0, 400), Punto(ANCHO, 400), 40, 'principal', DireccionCalle.HORIZONTAL, 3.0),
            Calle(Punto(ANCHO, 420), Punto(0, 420), 40, 'principal', DireccionCalle.HORIZONTAL, 3.0),
            
            # Av. de la Cultura - norte-sur
            Calle(Punto(700, 0), Punto(700, ALTO), 35, 'principal', DireccionCalle.VERTICAL, 2.8),
            Calle(Punto(720, ALTO), Punto(720, 0), 35, 'principal', DireccionCalle.VERTICAL, 2.8),
        ])
        
        # Calles del centro hist√≥rico (m√°s estrechas y empedradas)
        calles.extend([
            # Calle Plateros
            Calle(Punto(100, 300), Punto(600, 320), 20, 'empedrada', DireccionCalle.HORIZONTAL, 1.5),
            
            # Calle Procuradores
            Calle(Punto(150, 280), Punto(650, 300), 18, 'empedrada', DireccionCalle.HORIZONTAL, 1.2),
            
            # Cuesta San Blas (empinada)
            Calle(Punto(500, 200), Punto(580, 500), 25, 'empedrada', DireccionCalle.DIAGONAL, 1.0),
            
            # Calles alrededor de la Plaza de Armas
            Calle(Punto(300, 500), Punto(500, 500), 25, 'empedrada', DireccionCalle.HORIZONTAL, 1.5),
            Calle(Punto(500, 500), Punto(500, 600), 25, 'empedrada', DireccionCalle.VERTICAL, 1.5),
            Calle(Punto(500, 600), Punto(300, 600), 25, 'empedrada', DireccionCalle.HORIZONTAL, 1.5),
            Calle(Punto(300, 600), Punto(300, 500), 25, 'empedrada', DireccionCalle.VERTICAL, 1.5),
        ])
        
        # Calles secundarias
        calles.extend([
            Calle(Punto(200, 150), Punto(800, 180), 30, 'secundaria', DireccionCalle.HORIZONTAL, 2.0),
            Calle(Punto(400, 100), Punto(420, 350), 25, 'secundaria', DireccionCalle.VERTICAL, 2.0),
            Calle(Punto(900, 200), Punto(950, 700), 28, 'secundaria', DireccionCalle.VERTICAL, 2.2),
        ])
        
        return calles
    
    def _crear_semaforos_estrategicos(self):
        """Coloca sem√°foros en intersecciones importantes"""
        intersecciones_importantes = [
            (Punto(700, 400), 'principal'),  # Av. El Sol con Av. de la Cultura
            (Punto(400, 400), 'principal'),  # Intersecci√≥n central
            (Punto(500, 320), 'normal'),     # Plateros con conexi√≥n
            (Punto(300, 500), 'normal'),     # Entrada a Plaza de Armas
            (Punto(200, 170), 'normal'),     # Calle secundaria
        ]
        
        for posicion, tipo in intersecciones_importantes:
            self.semaforos.append(Semaforo(posicion, tipo))
    
    def _crear_patrones_horarios(self) -> dict:
        """Patrones de tr√°fico seg√∫n la hora del d√≠a"""
        return {
            'ma√±ana': {'factor': 1.2, 'tipos': [TipoVehiculo.AUTO, TipoVehiculo.COMBI, TipoVehiculo.TAXI]},
            'mediodia': {'factor': 0.8, 'tipos': [TipoVehiculo.AUTO, TipoVehiculo.MOTO]},
            'tarde': {'factor': 1.5, 'tipos': [TipoVehiculo.COMBI, TipoVehiculo.AUTO, TipoVehiculo.TAXI]},
            'noche': {'factor': 0.4, 'tipos': [TipoVehiculo.TAXI, TipoVehiculo.AUTO]}
        }
    
    def _generar_vehiculo_inteligente(self):
        """Generaci√≥n de veh√≠culos basada en patrones realistas"""
        tiempo_actual = time.time()
        
        # Determinar patr√≥n horario
        if 6 <= self.hora_simulada < 12:
            patron = self.patrones_horarios['ma√±ana']
        elif 12 <= self.hora_simulada < 18:
            patron = self.patrones_horarios['tarde']
        elif 18 <= self.hora_simulada < 22:
            patron = self.patrones_horarios['mediodia']
        else:
            patron = self.patrones_horarios['noche']
        
        # Verificar si debe generar seg√∫n el patr√≥n
        intervalo_base = random.uniform(1.0, 3.0)
        intervalo_ajustado = intervalo_base / patron['factor']
        
        if tiempo_actual - self.tiempo_ultima_generacion < intervalo_ajustado:
            return
        
        # Limitar veh√≠culos seg√∫n capacidad de la simulaci√≥n
        if len(self.vehiculos) >= 80:
            return
        
        # Seleccionar tipo de veh√≠culo seg√∫n patr√≥n
        tipo = random.choice(patron['tipos'])
        
        # Seleccionar calle inicial (preferir principales para mayor realismo)
        calles_disponibles = [c for c in self.calles if c.tipo in ['principal', 'secundaria']]
        calle_inicial = random.choice(calles_disponibles)
        
        # Posici√≥n inicial en la calle
        posicion_inicial = Punto(
            calle_inicial.inicio.x + random.uniform(0, 0.1) * (calle_inicial.fin.x - calle_inicial.inicio.x),
            calle_inicial.inicio.y + random.uniform(0, 0.1) * (calle_inicial.fin.y - calle_inicial.inicio.y)
        )
        
        vehiculo = Vehiculo(tipo, posicion_inicial, calle_inicial)
        
        # Crear ruta realista (2-5 calles)
        ruta = self._generar_ruta_realista(calle_inicial)
        vehiculo.establecer_ruta(ruta)
        
        self.vehiculos.append(vehiculo)
        self.vehiculos_generados += 1
        self.estadisticas[tipo.name.lower() + 's'] += 1
        self.tiempo_ultima_generacion = tiempo_actual
    
    def _generar_ruta_realista(self, calle_inicial: Calle) -> List[Calle]:
        """Genera una ruta realista conectando calles"""
        ruta = [calle_inicial]
        calle_actual = calle_inicial
        
        for _ in range(random.randint(2, 5)):
            # Buscar calles conectadas
            calles_conectadas = []
            for calle in self.calles:
                if calle != calle_actual:
                    # Verificar si las calles se conectan (distancia entre puntos < umbral)
                    if (calle_actual.fin.distancia_a(calle.inicio) < 50 or
                        calle_actual.fin.distancia_a(calle.fin) < 50):
                        calles_conectadas.append(calle)
            
            if calles_conectadas:
                calle_actual = random.choice(calles_conectadas)
                ruta.append(calle_actual)
            else:
                break
        
        return ruta
    
    def _actualizar_estadisticas(self):
        """Actualiza estad√≠sticas en tiempo real"""
        if not self.vehiculos:
            self.estadisticas['promedio_velocidad'] = 0
            self.estadisticas['congestion'] = 0
            return
        
        # Velocidad promedio
        velocidad_total = sum(v.velocidad_actual for v in self.vehiculos)
        self.estadisticas['promedio_velocidad'] = velocidad_total / len(self.vehiculos)
        
        # Nivel de congesti√≥n (0-100)
        vehiculos_lentos = sum(1 for v in self.vehiculos if v.velocidad_actual < v.velocidad_maxima * 0.5)
        self.estadisticas['congestion'] = min(100, (vehiculos_lentos / len(self.vehiculos)) * 100)
    
    def _dibujar_mapa_detallado(self):
        """Dibuja un mapa m√°s detallado y realista"""
        self.pantalla.fill(COLORES['FONDO'])
        
        # Dibujar calles con diferentes texturas
        for calle in self.calles:
            color = COLORES['ASFALTO']
            if calle.tipo == 'empedrada':
                color = COLORES['PIEDRA']
            elif calle.tipo == 'secundaria':
                color = COLORES['ASFALTO_VIEJO']
            
            # Calcular puntos para dibujar la calle como rect√°ngulo
            dx = calle.fin.x - calle.inicio.x
            dy = calle.fin.y - calle.inicio.y
            longitud = math.sqrt(dx*dx + dy*dy)
            
            if longitud > 0:
                # Vector unitario perpendicular
                ux = -dy / longitud
                uy = dx / longitud
                
                # Esquinas del rect√°ngulo de la calle
                ancho_mitad = calle.ancho / 2
                esquinas = [
                    (calle.inicio.x + ux * ancho_mitad, calle.inicio.y + uy * ancho_mitad),
                    (calle.inicio.x - ux * ancho_mitad, calle.inicio.y - uy * ancho_mitad),
                    (calle.fin.x - ux * ancho_mitad, calle.fin.y - uy * ancho_mitad),
                    (calle.fin.x + ux * ancho_mitad, calle.fin.y + uy * ancho_mitad)
                ]
                
                pygame.draw.polygon(self.pantalla, color, esquinas)
                
                # L√≠neas divisorias para calles principales
                if calle.tipo == 'principal' and calle.ancho > 30:
                    pygame.draw.line(self.pantalla, COLORES['LINEA_AMARILLA'],
                                   (calle.inicio.x, calle.inicio.y),
                                   (calle.fin.x, calle.fin.y), 2)
        
        # Dibujar edificios hist√≥ricos con m√°s detalle
        edificios = [
            # Catedral del Cusco
            {'rect': pygame.Rect(280, 480, 140, 140), 'tipo': 'catedral'},
            # Iglesia de la Compa√±√≠a
            {'rect': pygame.Rect(450, 520, 80, 100), 'tipo': 'iglesia'},
            # Qorikancha
            {'rect': pygame.Rect(600, 450, 100, 90), 'tipo': 'templo'},
            # Edificios coloniales
            {'rect': pygame.Rect(100, 100, 120, 180), 'tipo': 'colonial'},
            {'rect': pygame.Rect(250, 150, 100, 120), 'tipo': 'colonial'},
            {'rect': pygame.Rect(800, 200, 150, 160), 'tipo': 'colonial'},
            # Mercado San Pedro
            {'rect': pygame.Rect(50, 650, 200, 150), 'tipo': 'mercado'},
            # Edificios modernos
            {'rect': pygame.Rect(900, 100, 80, 200), 'tipo': 'moderno'},
            {'rect': pygame.Rect(1100, 300, 120, 250), 'tipo': 'moderno'},
        ]
        
        for edificio in edificios:
            if edificio['tipo'] == 'catedral':
                pygame.draw.rect(self.pantalla, COLORES['EDIFICIO_COLONIAL'], edificio['rect'])
                # Torres de la catedral
                torre1 = pygame.Rect(edificio['rect'].x + 20, edificio['rect'].y - 30, 30, 30)
                torre2 = pygame.Rect(edificio['rect'].x + 90, edificio['rect'].y - 30, 30, 30)
                pygame.draw.rect(self.pantalla, COLORES['EDIFICIO_COLONIAL'], torre1)
                pygame.draw.rect(self.pantalla, COLORES['EDIFICIO_COLONIAL'], torre2)
            elif edificio['tipo'] == 'colonial':
                pygame.draw.rect(self.pantalla, COLORES['EDIFICIO_COLONIAL'], edificio['rect'])
                # Detalles coloniales (balcones)
                balcon = pygame.Rect(edificio['rect'].x + 10, edificio['rect'].y + 40, 
                                   edificio['rect'].width - 20, 15)
                pygame.draw.rect(self.pantalla, (120, 60, 30), balcon)
            elif edificio['tipo'] == 'moderno':
                pygame.draw.rect(self.pantalla, COLORES['EDIFICIO_MODERNO'], edificio['rect'])
            else:
                pygame.draw.rect(self.pantalla, COLORES['EDIFICIO_COLONIAL'], edificio['rect'])
        
        # Plaza de Armas con m√°s detalle
        plaza = pygame.Rect(300, 500, 200, 100)
        pygame.draw.rect(self.pantalla, COLORES['PLAZA'], plaza)
        
        # Fuente en el centro de la plaza
        pygame.draw.circle(self.pantalla, (100, 100, 150), (400, 550), 20)
        pygame.draw.circle(self.pantalla, (150, 150, 200), (400, 550), 15)
        
        # Bancos y √°reas verdes
        for i in range(4):
            x = 320 + i * 40
            pygame.draw.rect(self.pantalla, (80, 60, 40), (x, 520, 20, 8))  # Bancos
        
        # A√±adir nombres de lugares
        font = pygame.font.Font(None, 28)
        lugares = [
            ("PLAZA DE ARMAS", 320, 470),
            ("CATEDRAL", 300, 460),
            ("AV. EL SOL", 20, 380),
            ("AV. DE LA CULTURA", 620, 50),
            ("SAN BLAS", 520, 180),
            ("MERCADO SAN PEDRO", 60, 630),
        ]
        
        for nombre, x, y in lugares:
            texto = font.render(nombre, True, COLORES['TEXTO'])
            # Sombra del texto
            sombra = font.render(nombre, True, (0, 0, 0))
            self.pantalla.blit(sombra, (x + 1, y + 1))
            self.pantalla.blit(texto, (x, y))
    
    def _mostrar_estadisticas_avanzadas(self):
        """Panel de estad√≠sticas m√°s completo"""
        # Fondo semitransparente para el panel
        panel = pygame.Surface((350, 200))
        panel.set_alpha(180)
        panel.fill((20, 20, 20))
        self.pantalla.blit(panel, (10, 10))
        
        font_titulo = pygame.font.Font(None, 32)
        font_stats = pygame.font.Font(None, 24)
        
        # T√≠tulo
        titulo = font_titulo.render("TR√ÅFICO CUSCO - TIEMPO REAL", True, COLORES['TEXTO'])
        self.pantalla.blit(titulo, (20, 20))
        
        # Hora simulada
        hora_texto = f"Hora: {int(self.hora_simulada):02d}:{int((self.hora_simulada % 1) * 60):02d}"
        hora_surface = font_stats.render(hora_texto, True, (200, 200, 255))
        self.pantalla.blit(hora_surface, (20, 50))
        
        # Estad√≠sticas de veh√≠culos
        stats_vehiculos = [
            f"üöó Autos: {self.estadisticas['autos']}",
            f"üöê Combis: {self.estadisticas['combis']}",
            f"üèçÔ∏è Motos: {self.estadisticas['motos']}",
            f"üöï Taxis: {self.estadisticas['taxis']}",
            f"Total activos: {len(self.vehiculos)}",
            f"Generados: {self.vehiculos_generados}"
        ]
        
        for i, stat in enumerate(stats_vehiculos):
            color = COLORES['TEXTO']
            if "Autos" in stat:
                color = COLORES['AUTO_ROJO']
            elif "Combis" in stat:
                color = COLORES['COMBI_AMARILLA']
            elif "Motos" in stat:
                color = COLORES['MOTO_ROJA']
            elif "Taxis" in stat:
                color = COLORES['TAXI']
            
            superficie = font_stats.render(stat, True, color)
            self.pantalla.blit(superficie, (20, 80 + i * 20))
        
        # M√©tricas de tr√°fico
        velocidad_promedio = self.estadisticas['promedio_velocidad']
        congestion = self.estadisticas['congestion']
        
        # Barra de velocidad promedio
        pygame.draw.rect(self.pantalla, (100, 100, 100), (200, 100, 120, 15))
        ancho_velocidad = int((velocidad_promedio / 3.0) * 120)  # M√°x 3.0
        color_velocidad = (0, 255, 0) if velocidad_promedio > 2 else (255, 255, 0) if velocidad_promedio > 1 else (255, 0, 0)
        pygame.draw.rect(self.pantalla, color_velocidad, (200, 100, ancho_velocidad, 15))
        
        vel_texto = font_stats.render(f"Velocidad: {velocidad_promedio:.1f}", True, COLORES['TEXTO'])
        self.pantalla.blit(vel_texto, (200, 80))
        
        # Barra de congesti√≥n
        pygame.draw.rect(self.pantalla, (100, 100, 100), (200, 140, 120, 15))
        ancho_congestion = int((congestion / 100) * 120)
        color_congestion = (255, 0, 0) if congestion > 70 else (255, 255, 0) if congestion > 40 else (0, 255, 0)
        pygame.draw.rect(self.pantalla, color_congestion, (200, 140, ancho_congestion, 15))
        
        cong_texto = font_stats.render(f"Congesti√≥n: {congestion:.0f}%", True, COLORES['TEXTO'])
        self.pantalla.blit(cong_texto, (200, 120))
    
    def _mostrar_controles(self):
        """Muestra los controles disponibles"""
        font_small = pygame.font.Font(None, 20)
        controles = [
            "CONTROLES:",
            "ESPACIO - Generar veh√≠culo",
            "R - Reiniciar simulaci√≥n", 
            "T - Cambiar hora del d√≠a",
            "C - Mostrar/ocultar calles",
            "ESC - Salir"
        ]
        
        for i, control in enumerate(controles):
            color = (255, 255, 100) if i == 0 else (200, 200, 200)
            superficie = font_small.render(control, True, color)
            self.pantalla.blit(superficie, (ANCHO - 200, 20 + i * 25))
    
    def ejecutar(self):
        """Bucle principal mejorado de la simulaci√≥n"""
        ejecutando = True
        mostrar_calles = True
        tiempo_inicio = time.time()
        
        print("üéÆ Iniciando Simulaci√≥n Avanzada del Tr√°fico en Cusco")
        print("=" * 50)
        print("Caracter√≠sticas implementadas:")
        print("‚úÖ Comportamientos realistas por tipo de veh√≠culo")
        print("‚úÖ Red de calles del centro hist√≥rico")
        print("‚úÖ Sem√°foros inteligentes")
        print("‚úÖ Patrones de tr√°fico por horarios")
        print("‚úÖ Estad√≠sticas en tiempo real")
        print("‚úÖ Mapa detallado con landmarks")
        
        while ejecutando:
            for evento in pygame.event.get():
                if evento.type == pygame.QUIT:
                    ejecutando = False
                elif evento.type == pygame.KEYDOWN:
                    if evento.key == pygame.K_SPACE:
                        self._generar_vehiculo_inteligente()
                    elif evento.key == pygame.K_r:
                        # Reiniciar simulaci√≥n
                        self.vehiculos.clear()
                        self.vehiculos_generados = 0
                        self.estadisticas = {k: 0 for k in self.estadisticas.keys()}
                    elif evento.key == pygame.K_t:
                        # Cambiar hora del d√≠a
                        self.hora_simulada = (self.hora_simulada + 2) % 24
                    elif evento.key == pygame.K_c:
                        mostrar_calles = not mostrar_calles
                    elif evento.key == pygame.K_ESCAPE:
                        ejecutando = False
            
            # Avanzar hora simulada lentamente
            self.hora_simulada += 0.001  # Muy lento para observar cambios
            if self.hora_simulada >= 24:
                self.hora_simulada = 0
            
            # Generar veh√≠culos autom√°ticamente
            if len(self.vehiculos) < 100:  # L√≠mite aumentado
                if random.random() < 0.3:  # 30% chance por frame
                    self._generar_vehiculo_inteligente()
            
            # Actualizar sem√°foros
            for semaforo in self.semaforos:
                semaforo.actualizar()
            
            # Actualizar veh√≠culos
            for vehiculo in self.vehiculos[:]:
                if not vehiculo.actualizar(self.vehiculos, self.semaforos):
                    self.vehiculos.remove(vehiculo)
            
            # Actualizar estad√≠sticas
            self._actualizar_estadisticas()
            
            # Dibujar todo
            if mostrar_calles:
                self._dibujar_mapa_detallado()
            else:
                self.pantalla.fill(COLORES['FONDO'])
            
            # Dibujar elementos de tr√°fico
            for semaforo in self.semaforos:
                semaforo.dibujar(self.pantalla)
            
            for vehiculo in self.vehiculos:
                vehiculo.dibujar(self.pantalla)
            
            # Interfaz
            self._mostrar_estadisticas_avanzadas()
            self._mostrar_controles()
            
            pygame.display.flip()
            self.reloj.tick(FPS)
        
        # Estad√≠sticas finales
        tiempo_total = time.time() - tiempo_inicio
        print(f"\nüìä RESUMEN DE LA SIMULACI√ìN:")
        print(f"Tiempo total: {tiempo_total:.1f} segundos")
        print(f"Veh√≠culos generados: {self.vehiculos_generados}")
        print(f"Promedio de veh√≠culos por minuto: {(self.vehiculos_generados / tiempo_total) * 60:.1f}")
        
        pygame.quit()

if __name__ == "__main__":
    print("üèõÔ∏è SIMULACI√ìN DE TR√ÅFICO - CENTRO HIST√ìRICO DEL CUSCO")
    print("=" * 60)
    print("Una simulaci√≥n realista que incluye:")
    print("üöó Diferentes tipos de veh√≠culos con comportamientos √∫nicos")
    print("üèõÔ∏è Mapa detallado basado en el centro hist√≥rico real")
    print("üö¶ Sistema de sem√°foros inteligente")
    print("‚è∞ Patrones de tr√°fico que cambian seg√∫n la hora")
    print("üìä Estad√≠sticas completas en tiempo real")
    print("üéÆ Controles interactivos para explorar la simulaci√≥n")
    print("\nPresiona cualquier tecla en la ventana para comenzar...")
    
    try:
        simulacion = SimulacionTrafico()
        simulacion.ejecutar()
    except KeyboardInterrupt:
        print("\nüëã Simulaci√≥n terminada por el usuario")
    except Exception as e:
        print(f"\n‚ùå Error en la simulaci√≥n: {e}")
        print("Aseg√∫rate de tener pygame instalado: pip install pygame")
